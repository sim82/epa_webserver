class Reformat
  
attr_reader :data, :format
attr_accessor :format

  def initialize(file)
    f = File.open(file,'r')
    @data = f.readlines
    @format = "unk"
    f.close
  end

  def detectFormat #Auto_detection
    i = 0
    while i < @data.size

      if @data[i] =~ /^>/
        j = i
        #fasta checking
      elsif @data[i] =~ /^\d+\s+\d+$/
        #check for phylip format
      end
      i = i+1
    end
  end
  
  def reformatToStockholm
    supported = ["phy"]
    i = 0

    if @format.eql?("phy")
      while i < @data.size
        if @data[i] =~ /^\d+\s+\d+$/
          @data[i] = "# STOCKHOLM 1.0"
          @format = "sto"
          break
        end
        i = i+1
      end
      @data << "//"
    else
      message =  "Cannot convert #{@format} to Phylip format! Following formats a supported:"
      supported.each {|s| message = message+" "+s}
      raise message
    end
  end

  def reformatToPhylip
    supported = ["fas","sto"]
    i = 0

    if @format.eql?("fas")
      phylip = []
      (names, seqs, lens,rows) = readfa(@data)
      max_name = names.map{ |n| n.length }.max
      phylip << "#{names.size} #{lens[0]}"
      names.each do |name|
        phylip << "#{pad_right(max_name + 1, name)}#{seqs[name]}" 
      end
      @data = phylip
      @format = "phy"
      
    elsif @format.eql?("sto")   
      names = []
      data = {}
      phylip  = []
      len = nil
      maxnlen = 0
      @data.each_line do |l|
        if l =~ /^(\S+)\s+(\S+)$/
          n = $1
          d = $2.gsub( /\./, "-" )
          names << n
          data[n] = d
          
          maxnlen = [maxnlen, n.length].max
          
          if len != nil && len != d.length
            raise "not equal seq lengths"
          end
          len = d.length
        end
      end
      phylip << "#{names.length} #{len}"
      names.each do |n|
        phylip <<( "#{n}#{" " * (maxnlen + 1 - n.length)}#{data[n]}")
      end
      @data = phylip
      @format = "phy"

    else
      message =  "Cannot convert #{@format} to Phylip format! Following formats a supported:"
      supported.each {|s| message = message+" "+s}
      raise message
    end
  end

  def writeToFile(file)
    f = File.open(file,'wb')
    @data.each {|line| f.write(line+"\n")}
    f.close
  end


######################
### Helper Methods ###
  private
  def readfa(fh)
    rows = 0
    names = []
    seqs = {}
    lens = []
    curname = nil
    curseq = nil
    minlen = 1000000
    maxlen = -1
    
    fh.each do |line|
      name = nil
      data = nil
      if line =~ />\s*(\S+)/
        if( curseq != nil )
          seqs[curname] = curseq;
          names << curname;
          lens << curseq.length
        end
        rows += 1
        curname = $1;
        curseq = ""
        
      elsif curname != nil
        line.gsub!( /\s/, "" )
        curseq += line
      end
    end
    
    seqs[curname] = curseq;
    names << curname;
    lens << curseq.length
    
    return [names, seqs, lens, rows];
  end
  
  private
  def pad_right( n, s )
    if( s.length < n )
      return s + (" " * (n - s.length))
    else
      return s;
    end
  end
  
end







